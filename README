A light-weight Key-Value Database System
------------------------------------------
This work is mainly inspired by LevelDB and yodb.
------------------------------------------
Design Principle,
In our work, we use chain-hash and extensible hash as the internal structure of this system. This system is constructed by three parts, internal structure, cache and elements managment.
------------------------------------------
Compilation
CustomDB use GNU Make to handle compilation, you can find detail information from this url, www.gnu.com/Make/.

I have just tested it on Ubuntu 13.10, so if you have any problem, please send email to me.

On my computer, the compilation progree

$ make
$ make test
$ sudo make install

After make install, the libCustomDB will be moved into /usr/local and all header files will be copied to /usr/include/CustomDB.
---------------------------------------------
Basic Performance Test,

CustomDB:   version 0.1
Date:       Sun Jan 26 23:12:29 2014
CPU:        4 * Intel(R) Core(TM) i5-3317U CPU @ 1.70GHz
CPUCache:   3072 KB
Keys:       16 bytes each
Values:     100 bytes each (100 bytes after compression)
Entries:    100000
RawSize:    11.1 MB (estimated)
FileSize:   11.1 MB (estimated)
WARNING: Optimization is disabled: benchmarks unnecessarily slow
WARNING: Assertions are enabled; benchmarks unnecessarily slow


---------------------------------------------
Open CustomDB files,

```c++
#include <CustomDB/Option.h>
#include <CustomDB/CustomDB.h>

int main()
{
	Option option; //User can just use the default option, for further selection, please refer for Option parts.

	CustomDB db = new CustomDB;
	
	db -> init(option);	

	db -> close();
	
	delete db;
}
```
---------------------------------------------
Dump Database files into terminal,

```c++
#include <CustomDB/Option.h>
#include <CustomDB/CustomDB.h>

int main()
{
	Option option;
	CustomDB db = new CustomDB;
	db -> init(option);	
	
	db -> dump();
	
	db -> close();
	delete db;
}
```
-------------------------------------
Put elements in the Database

```c++
Slice key("slice"); //Slice is used to manpiate the item in the database
Slice value("123213");

db -> put(key, value); // Return value will give out whether we put it successfully.

db -> put("123213","iipppp"); //Another way to Put elements in it.
```

--------------------------------------
Get elements in the Database

```c++
Slice key("slice"); 

Slice value = db -> get(key); 

/**
	if(value.size() == 0) we didn't find the key in the database
	if(value.size() != 0) the return value is the corspond value of the key.
**/

-----------------------------------
Remove elements in the Database

```c++
Slice key("slice");
bool successful = db -> remove(key); // same return value as put
```
-------------------------------------
Option selection,
-------------------------------------
The simplest demo for this project
--------------------------------------------------------------------------
Prerequisite:

GTest for Test in this project.
C++0x, as I use thread and other property in C++0x.
---------------------------------------------------------
TODO List:

1. Test
2. JSON
3. Lock
4. Parallel
5. Other support
6. Vim or others

------------------------------------------

I guess I will make some other tasks to implement the DB, like 3.

Also,

7. Memory Pool 
8. Thread Pool
9. AIO, IOCP

Are very import in this project.

-------------------------------------------------------------
Basic performance, put 65s/1M, read 33s/1M. Without any external cache. 33% usage. use cache `4s`?
-------------------------------------------------------------
V0.02, add page-cache feature, performance is bad than previous experiment.

Got it why the result looks good in previous failed experiment(Almost not change page, -1).

Advice: use background thread to save page or pageelement into files.
--------------------------------------------------------------
V0.03, add batch mode(maybe slient batch)

Speed performance, 25s/100M, and the speed will be slow enough with the increasing of the test data.

V0.035, the fasted record is 10.5s/100M in my experiment.
--------------------------------------------------------------
V0.04, add multiple-threading programming technology.
Speed is almost same as previous experiment(I guess the parallel technology I take affects it).

Add another mp technolgy, however, the performance is still the same. Bottleneck is in disk?

V0.045, add `log lock` and `cache lock`. The style of `cache lock` is very ugly.

How to use lock(atomic or others)?
--------------------------------------------------------------
V0.05, add async-w/r technology.
--------------------------------------------------------------
V0.06, add compact feature, add log disabled option
Performance, when we disabled the log, the read performance has obvious advancement.

Great, achieve compact. However. the efficiency of compact is very slow when we use batch in write phase. However, it can achieve 34M/57M performance in general put method. Further optimization can be adopted. However, very hard and time-consuming.
--------------------------------------------------------------
V0.07 Add fast search in Split

10%~20% performance improvement. Not very ideal.
--------------------------------------------------------------
Best practise in coding life,
1. Build it
2. Write(find) a basic test to testify it
--------------------------------------------------------------
Bottleneck has been found, the updated time of page.

Three method to remedy it.

1. AIO
2. Use fcntl(However, need much times to implement it.)
3. MMAP + dup, maybe.